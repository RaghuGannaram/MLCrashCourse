<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>NN Live Viewer</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <style>
            :root {
                --bg: #ffffff;
                --fg: #0b0d10;
                --muted: #7d8aa3;
                --edge: #9fb0c3;
                --node-stroke: #6a90d6;
                --badge-bg: #eef5ff;
                --badge-stroke: #c9dcff;
                --warn: #b54708;
                --ok: #2b825b;
                --err: #b42318;
            }
            html,
            body {
                height: 100%;
            }
            body {
                margin: 0;
                background: var(--bg);
                color: var(--fg);
                font: 14px/1.4 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
                overflow: hidden;
            }

            .edge {
                stroke: var(--edge);
                stroke-opacity: 0.9;
            }
            .node {
                /* fill: #d5e3ff; */
                /* stroke: var(--node-stroke); */
                /* stroke-width: 1.5; */
            }
            .nodeText {
                fill: var(--fg);
                font-size: 11px;
                text-anchor: middle;
                dominant-baseline: middle;
                pointer-events: none;
            }
            .layerLabel {
                fill: #2b3a55;
                opacity: 0.6;
                font-size: 12px;
                font-weight: 600;
                text-anchor: middle;
            }
            .biasText {
                fill: #6b7a90;
                font-size: 10px;
                text-anchor: middle;
            }

            .control-container {
                margin: 20px;
                display: flex;
                gap: 10px;
                align-items: center;
                pointer-events: none;
            }
            .control-container .group {
                display: flex;
                align-items: center;
                gap: 10px;
            }
            .chip {
                pointer-events: auto;
                user-select: none;
                display: inline-flex;
                align-items: center;
                gap: 6px;
                padding: 6px 10px;
                border-radius: 999px;
                background: var(--badge-bg);
                border: 1px solid var(--badge-stroke);
                font-size: 12px;
            }
            .chip button {
                all: unset;
                cursor: pointer;
                padding: 0 6px;
                border-radius: 8px;
            }
            .chip .sep {
                width: 1px;
                align-self: stretch;
                background: var(--badge-stroke);
                margin: 0 4px;
            }
            .status.ok {
                color: var(--ok);
            }
            .status.warn {
                color: var(--warn);
            }
            .status.err {
                color: var(--err);
            }

            .canvas-container {
                padding: 40px 20px;
                margin: auto;
            }

            .legend-container {
                position: fixed;
                bottom: 10px;
                right: 10px;
                z-index: 10;
                background: rgba(255, 255, 255, 0.85);
                border: 1px solid var(--badge-stroke);
                border-radius: 10px;
                padding: 10px 12px;
                font-size: 12px;
                backdrop-filter: blur(4px);
            }
            .legend-container h4 {
                margin: 0 0 6px 0;
                font-size: 12px;
                font-weight: 700;
                color: #243b66;
            }
            .legend-container ul {
                list-style: none;
                padding: 0;
                margin: 0;
            }
            .legend-container li {
                margin: 4px 0;
            }
        </style>
    </head>
    <body>
        <!-- Controls -->
        <div class="control-container" aria-live="polite">
        <div class="group">

            
            <div class="chip" id="modelChip" title="Model size (includes Input layer)">
                <strong>Model</strong><span class="sep"></span>
                <span id="layersVal">L=0</span>
                <span style="margin:0 4px;">·</span>
                <span id="neuronsVal">N=0</span>
                <span style="margin:0 4px;">·</span>
                <span id="weightsVal">W=0</span>
            </div>

            <div class="chip" id="stepChip">
                <strong>Step</strong><span class="sep"></span><span id="stepVal">—</span>
            </div>

            <div class="chip" id="modeChip" title="Switch between Values and Gradients view">
                <strong>Loss</strong><span class="sep"></span>
                <span id="lossVal"></span>
            </div>

            <div class="chip" id="timeChip" title="Snapshot timestamp">
                <strong>Trained:</strong><span class="sep"></span><span id="timeStampVal">—</span>
            </div>

            <div class="chip" id="pollChip" title="Polling interval">
                <strong>Poll</strong><span class="sep"></span><span id="pollVal">500ms</span>
            </div>
        </div>

        <div class="group" style="margin-left: auto">
            <div class="chip status ok" id="status">● Connected</div>
        </div>
        </div>


        <!-- Canvas -->
        <div class="canvas-container">
            <svg
                id="svg"
                viewBox="0 0 1200 700"
                preserveAspectRatio="xMidYMid meet"
                role="img"
                aria-label="Neural network live viewer"
            ></svg>
        </div>

        <!-- Legend -->
        <div class="legend-container" id="legend">
        <h4>Legend</h4>
        <ul>
            <li><strong>Node color</strong>: activation (orange‑red −, white ≈ 0, blue +)</li>
            <li><strong>Input nodes</strong>: gray circles labeled x₁…xₙ</li>
            <li><strong>Outer ring</strong>: |bias| → ring thickness; dashed if bias &lt; 0</li>
            <li><strong>Edge width</strong>: |weight|; dashed if weight &lt; 0</li>
        </ul>
        </div>

        <script>
            const API_URL = "http://localhost:8000/latest";
            const POLL_INTERVAL = 100;

            // ---------- STATE ----------
            const svg = document.getElementById("svg");
            const lossVal = document.getElementById("lossVal");
            const layersVal = document.getElementById("layersVal");
            const neuronsVal = document.getElementById("neuronsVal");
            const weightsVal = document.getElementById("weightsVal");
            const stepVal = document.getElementById("stepVal");
            const timeStampVal = document.getElementById("timeStampVal");
            const pollVal = document.getElementById("pollVal");
            const statusChip = document.getElementById("status");

            pollVal.textContent = `${POLL_INTERVAL}ms`;

            async function fetchSnapshot() {
                try {
                    const res = await fetch(API_URL + "?_t=" + Date.now(), { cache: "no-store" });
                    if (!res.ok) throw new Error("HTTP " + res.status);

                    const data = await res.json();

                    return data;
                } catch (error) {
                    console.error("Error fetching snapshot:", error);
                    return null;
                }
            }

            function clearSVG() {
                while (svg.firstChild) svg.removeChild(svg.firstChild);
            }

            function add(tag, attrs = {}, parent = svg) {
                const element = document.createElementNS("http://www.w3.org/2000/svg", tag);

                for (const [k, v] of Object.entries(attrs)) element.setAttribute(k, v);

                parent.appendChild(element);
                return element;
            }

            function formatNumber(x) {
                const n = Number(x);
                if (!Number.isFinite(n)) return "—";

                return Math.abs(n) >= 1000 ? n.toExponential(2) : n.toFixed(4);
            }

            function getWidthByMagnitude(val, min = 0.5, max = 8, cap = 3) {
                const a = Math.min(Math.abs(Number(val) || 0), cap) / cap;

                return (min + a * (max - min)).toFixed(2);
            }

            function getActivationColor(a, opts = {}) {
                const {
                    cap = 5.0, // value where the ramp "tops out" (tune per model)
                    negHue = 18, // orange-red for positives
                    posHue = 210, // blue for negatives (fallback)
                    minSat = 20, // % saturation at 0
                    maxSat = 80, // % saturation at cap
                    minLight = 40, // % lightness at cap
                    maxLight = 95, // % lightness at 0
                    gamma = 0.9, // <1 boosts contrast near 0, >1 compresses
                    useLog = true, // log scale for wide ranges
                } = opts;

                const x = Number(a);
                if (!Number.isFinite(x)) return `hsl(${posHue} 0% 90%)`;

                const sign = x < 0 ? -1 : x > 0 ? 1 : 0;
                const mag = Math.abs(x);

                // Scale 0..cap → 0..1, with optional log for better resolution near 0
                const scaled = useLog ? Math.log1p(Math.min(mag, cap)) / Math.log1p(cap) : Math.min(mag / cap, 1);

                const t = Math.pow(scaled, gamma); // ease curve

                const hue = sign < 0 ? negHue : posHue;
                const sat = minSat + (maxSat - minSat) * (sign === 0 ? 0 : t);
                const light = maxLight - (maxLight - minLight) * (sign === 0 ? 0 : t);

                return `hsl(${hue} ${sat}% ${light}%)`;
            }

            function getRingWidthByMagnitude(b, min = 1, max = 6, cap = 2.5) {
                const a = Math.min(Math.abs(Number(b) || 0), cap) / cap;

                return (min + a * (max - min)).toFixed(1);
            }

            function draw(snapshot) {
                clearSVG();

                function makeInputLayer(snapshot, baseLayers) {
                    const rawX = snapshot.input ?? snapshot.x ?? snapshot.features ?? null;
                    const inferredSize = baseLayers[0]?.neurons?.[0]?.weights?.length ?? 0;

                    const inputSize = rawX ? rawX.length : inferredSize;
                    const neurons = Array.from({ length: inputSize }, (_, i) => ({
                        isInput: true,
                        activation: null,
                    }));

                    return { layer: "input", neurons };
                }

                const baseLayers = snapshot.layers || [];
                if (!baseLayers.length) return;

                const inputLayer = makeInputLayer(snapshot, baseLayers);
                const layers = [inputLayer, ...baseLayers];

                const Width = 1000,
                    Height = 500;
                const paddingLeft = 120,
                    paddingRight = 80,
                    paddingTop = 80,
                    paddingBottom = 80;
                const usableWidth = Width - paddingLeft - paddingRight;
                const usableHeight = Height - paddingTop - paddingBottom;

                const positions = {};

                layers.forEach((layer, li) => {
                    const xGap = layers.length > 1 ? usableWidth / (layers.length - 1) : 0;
                    const yGap = layer.neurons.length > 1 ? usableHeight / (layer.neurons.length - 1) : 0;

                    add("text", { x: paddingLeft + li * xGap, y: 28, class: "layerLabel" }).textContent = (() => {
                        if (layer.layer === "input") {
                            return `input (${layer.neurons.length})`;
                        }
                        const fanIn = layer.neurons[0]?.weights?.length ?? 0;
                        const fanOut = layer.neurons.length;

                        return `${layer.layer} (${fanIn}→${fanOut})`;
                    })();

                    for (let neuronIndex = 0; neuronIndex < layer.neurons.length; neuronIndex++) {
                        positions[`${layer.layer}/N${neuronIndex}`] = {
                            x: paddingLeft + li * xGap,
                            y: paddingTop + (layer.neurons.length === 1 ? usableHeight / 2 : neuronIndex * yGap),
                        };
                    }
                });

                for (let layerIndex = 0; layerIndex < layers.length - 1; layerIndex++) {
                    const source = layers[layerIndex],
                        destination = layers[layerIndex + 1];

                    for (let j = 0; j < destination.neurons.length; j++) {
                        const weightsArr = destination.neurons[j].weights || [];

                        for (let i = 0; i < weightsArr.length; i++) {
                            const val = Number(weightsArr[i]) || 0;
                            const a = positions[`${source.layer}/N${i}`];
                            const b = positions[`${destination.layer}/N${j}`];

                            if (!a || !b) continue;

                            const line = add("line", {
                                x1: a.x,
                                y1: a.y,
                                x2: b.x,
                                y2: b.y,
                                class: "edge",
                                "stroke-width": getWidthByMagnitude(val),
                                "stroke-dasharray": val < 0 ? "6 4" : "0",
                            });

                            // const dx = b.x - a.x, dy = b.y - a.y;
                            // const mx = (a.x + b.x) / 2, my = (a.y + b.y) / 2;

                            // // optional: offset a bit perpendicular to the edge so it's not on top of the line
                            // const len = Math.hypot(dx, dy) || 1;
                            // const nx = -dy / len, ny =  dx / len;
                            // const offset = 8;

                            // const edgeText = add("text", {
                            //     x: mx + nx * offset,
                            //     y: my + ny * offset,
                            //     class: "edgeLabel",
                            //     "font-size": "10",       // or set via CSS
                            //     fill: "#2b3a55"          // SVG uses 'fill' for text color
                            // });
                            // edgeText.textContent = `w=${formatNumber(val)}`;
                        }
                    }
                }

                layers.forEach((layer) => {
                    const radius = 24;

                    layer.neurons.forEach((neuron, neuronIndex) => {
                        const position = positions[`${layer.layer}/N${neuronIndex}`];
                        if (!position) return;

                        const activation = Number(neuron.activation ?? NaN);
                        const bias = Number(neuron.bias);

                        const node = add("circle", { cx: position.x, cy: position.y, r: radius, class: "node" });
                        node.setAttribute("fill", getActivationColor(activation));

                        const ring = add("circle", {
                            cx: position.x,
                            cy: position.y,
                            r: radius + 3,
                            fill: "none",
                            stroke: "#6a90d6",
                            "stroke-dasharray": Number(bias) < 0 ? "5 3" : "0",
                            "stroke-opacity": 0.7,
                        });
                        ring.setAttribute("stroke-width", getRingWidthByMagnitude(bias));

                        const activationText = add("text", { x: position.x, y: position.y, class: "nodeText" });
                        activationText.textContent = formatNumber(activation);

                        const biasText = add("text", { x: position.x, y: position.y + radius + 14, class: "biasText" });
                        biasText.textContent = `b=${formatNumber(bias)}`;

                        if (layer.layer === "input") {
                            node.setAttribute("fill", "grey");
                            node.setAttribute("stroke", "grey");
                            node.setAttribute("stroke-width", "1.5");
                            activationText.textContent = `x${neuronIndex + 1}`;
                            biasText.textContent = "";
                        }
                    });
                });
            }

            async function tick() {
                const data = await fetchSnapshot();

                if (!data || !data.snapshot) {
                    console.warn("No valid snapshot received");
                    return;
                }
                console.log(data.snapshot.layers.at(-1).neurons[0].activation, data.snapshot.layers.at(-1).neurons[0].gradient)
                lossVal.textContent = formatNumber(data.loss);
                stepVal.textContent = `${data.step}`;
                timeStampVal.textContent = `${new Date(data.timestamp * 1000).toLocaleTimeString()}`;
                layersVal.textContent = `L=${data.info.layers}`;
                neuronsVal.textContent = `N=${data.info.neurons}`;
                weightsVal.textContent = `W=${data.info.weights}`;

                draw(data.snapshot);
            }

            function loop() {
                tick().finally(() => setTimeout(loop, POLL_INTERVAL));
            }

            loop();
        </script>
    </body>
</html>
